/*
 * MOSES telemetry ground station test code
 * 
 * Author: Roy Smart
 * History:
 *      Created Apr 28 2014
 *      Tested May 9 2014 successfully at White Sands Missile Range
 * 
 * Uses the Microgate USB Synclink adapter to receive 10 Mbps telemetry data from
 * TS-7600 flight computer and sendTM.c written by Jake Plovanic.
 * 
 * This program requires that ./mgslutil be run beforehand to configure the Synclink device.
 * 10 Mbps is only possible in rs422 mode.
 * 
 *      ./mgslutil rs422
 * 
 * receive HDLC/SDLC data and write received data to a file
 * 
 * Code is based off of receive-hdlc.c sample code provided by Microgate
 *
 * This sample demonstrates HDLC communications using a
 * SyncLink serial card. The companion sample send-hdlc.c sends
 * HDLC data. Use both programs to send data between two serial cards
 * connected with a NULL modem (cross over cable) or other serial link.
 *
 * The sample is simple to clearly show basic programming concepts.
 * Use this code to start development of more complex applications.
 *
 * Overview:
 *
 * 1. open serial device (syscall open)
 * 2. configure serial device (syscall ioctl)
 * 3. receive data from serial device (syscall read)
 * 4. write received data to a file
 *
 */

#include <stdio.h>
#include <stdlib.h>
#include <memory.h>
#include <signal.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <linux/types.h>
#include <termios.h>
#include <errno.h>
#include <sys/time.h>

#include "synclink.h"

#ifndef N_HDLC
#define N_HDLC 13
#endif

#ifndef BUFSIZ
#define BUFSIZ 4096
#endif

/*
 * set base clock frequency in cycles per second
 *
 * Data clocks are generated by dividing a fixed base clock by a 16-bit integer.
 * GT family base clock default is 14.7456MHz.
 *
 * Other base clocks (up to 33MHz) can be installed
 * at the factory by special order. Non default values require driver
 * configuration with the actual value so correct divisors are used for
 * a specified data rate.
 */
int set_base_clock(int fd, unsigned int freq) {
    MGSL_PARAMS params;
    int rc;

    /* fields other than mode and clock_speed are ignored */
    params.mode = MGSL_MODE_BASE_CLOCK;
    params.clock_speed = freq;
    rc = ioctl(fd, MGSL_IOCSPARAMS, &params);
    if (rc < 0) {
        printf("set base clock frequency error=%d %s\n",
                errno, strerror(errno));
    }
    return rc;
}

FILE * openFile(char* name) {

    FILE *fp = NULL;
    fp = fopen(name, "wb+");
    if (fp == NULL) {
        printf("fopen error=%d %s\n", errno, strerror(errno));
        //return errno;
    }
    //printf("filePath:%ld\n", (long) (fp));
    return fp;
}

/* handle SIGINT - do nothing */
void sigint_handler(int sigid) {
}

int main(int argc, char* argv[]) {
    int fd, rc;
    FILE *fp = NULL;
    FILE *outxml = NULL;
    int ldisc = N_HDLC;
    MGSL_PARAMS params;
    int sigs, idle, errcheck;
    int xml_check3 = 0;
    char *xml_header = malloc(strlen("<ROEIMAGE>") + 1);
    int numImages = 14;
    int fileCount = 0;
    int count = 0;
    int totalFileSize = 0;
    unsigned char buf[BUFSIZ];
    size_t size = BUFSIZ;
    char *devname;
    char *xml_name;

    struct timeval runtime_begin, runtime_end;
    int runtime_elapsed;

    struct mgsl_icount icount;

    if (argc > 1)
        devname = argv[1];
    else
        devname = "/dev/ttyUSB0";

    printf("receive HDLC data on %s\n", devname);
    printf("receiving/writing %d files\n", numImages);


    /* open serial device with O_NONBLOCK to ignore DCD input */
    fd = open(devname, O_RDWR | O_NONBLOCK, 0);

    
    gettimeofday(&runtime_begin, NULL); //Timing

    if (fd < 0) {
        printf("open error=%d %s\n", errno, strerror(errno));
        return errno;
    } else printf("%s port opened\n", devname);

    /*
     * set N_HDLC line discipline
     *
     * A line discipline is a software layer between a tty device driver
     * and user application that performs intermediate processing,
     * formatting, and buffering of data.
     */
    rc = ioctl(fd, TIOCSETD, &ldisc); //Change to N_TTY?
    if (rc < 0) {
        printf("set line discipline error=%d %s\n",
                errno, strerror(errno));
        return rc;
    }

    /*log debugging*/


    /* required only if custom base clock (not 14745600) installed */
    /*
            if (set_base_clock(fd, 32000000) < 0) {
                    return rc;
            }
     */

    // get current device parameters
    rc = ioctl(fd, MGSL_IOCGPARAMS, &params);
    if (rc < 0) {
        printf("ioctl(MGSL_IOCGPARAMS) error=%d %s\n",
                errno, strerror(errno));
        return rc;
    }


    /*
     * modify device parameters
     *
     * HDLC/SDLC mode, loopback disabled, NRZ encoding
     * Data clocks sourced from clock input pins
     * Output 9600bps clock on auxclk output
     * Hardware generation/checking of CCITT (ITU) CRC 16
     */

    params.mode = MGSL_MODE_HDLC; //Change to N_TTY?
    params.loopback = 0;
    params.flags = HDLC_FLAG_RXC_RXCPIN + HDLC_FLAG_TXC_TXCPIN;
    params.encoding = HDLC_ENCODING_NRZ;
    params.clock_speed = HDLC_FLAG_TXC_BRG;
    params.crc_type = HDLC_CRC_16_CCITT;
    params.preamble = HDLC_PREAMBLE_PATTERN_ONES; //Remove?
    params.preamble_length = HDLC_PREAMBLE_LENGTH_16BITS;

    /* set current device parameters */
    rc = ioctl(fd, MGSL_IOCSPARAMS, &params);
    if (rc < 0) {
        printf("ioctl(MGSL_IOCSPARAMS) error=%d %s\n",
                errno, strerror(errno));
        return rc;
    }


    printf("Turn on RTS and DTR serial outputs\n");
    sigs = TIOCM_RTS | TIOCM_DTR;
    rc = ioctl(fd, TIOCMBIC, &sigs);
    if (rc < 0) {
        printf("assert DTR/RTS error=%d %s\n", errno, strerror(errno));
        return rc;
    }

    /* set device to blocking mode for reads and writes */
    fcntl(fd, F_SETFL, fcntl(fd, F_GETFL) + ~O_NONBLOCK);

    /* set ctrl-C to interrupt syscall but not exit program */
    printf("Press Ctrl-C to stop program.\n");
    signal(SIGINT, sigint_handler);
    siginterrupt(SIGINT, 1);

    /*enable receiver*/
    int enable = 2;
    rc = ioctl(fd, MGSL_IOCRXENABLE, enable);

    outxml = fopen("/data_output/imageindex.xml","w+");
    if (outxml == NULL) {
        printf("fopen error=%d %s\n", errno, strerror(errno));
        //return errno;
    }
    /* Write XML declaration */
    fprintf(outxml, "<?xml version=\"1.0\" encoding=\"ASCII\" standalone=\"yes\"?>\n");
    fprintf(outxml, "<CATALOG>\n");
    
    fp = openFile("/data_output/image_buf");

    fileCount++;

    /*crc check setup*/
    rc = ioctl(fd, MGSL_IOCGSTATS, &icount);
    __u32 crctemp = icount.rxcrc;

    int index = 0; //line counter to verify data is still being sent

    for (;;) {
        
        /*check crc*/
        rc = ioctl(fd, MGSL_IOCGSTATS, &icount); //needed?
        if (crctemp != icount.rxcrc) {
            printf("    CRC Failed!\n");
        }
        crctemp = icount.rxcrc;

        /* get received data from serial device */
        memset(buf, 0, BUFSIZ);
        rc = read(fd, buf, size);

        if (rc < 0) {
            printf("read error=%d %s\n", errno, strerror(errno));
            break;
        }
        else if (rc == 0) {
            gettimeofday(&runtime_end, NULL); //Timing
            runtime_elapsed = 1000000 * ((long) (runtime_end.tv_sec) - (long) (runtime_begin.tv_sec)) + (long) (runtime_end.tv_usec) - (long) (runtime_begin.tv_usec);
            printf("program ran for %-3.2f seconds before failing\n", (float) runtime_elapsed / (float) 1000000);
            printf("read returned with no data - set NONBLOCK mode to continue\n");
            break;
        }
        else if (rc == 16) {
            /*Terminating characters for xml*/
            printf("received %d bytes       %d       [ TERM ]\n", rc, index);
            printf("%d total bytes received for file: %s\n", totalFileSize, buf);
            printf("creating new image buffer\n");
            
            fflush(fp);
            fclose(fp);
            sprintf(buf, "/data_output/%s", buf);
            rename("/data_output/image_buf", buf);
            fp = openFile("/data_output/image_buf");

            fileCount++;
            totalFileSize = 0;
            index = 0;
            printf("filePath:%ld     fileCount:%d    totalSize:%d    index:%d\n", (long) (fp), fileCount, totalFileSize, index);
        }
        else if (rc == 14){
            /*Terminating characters for xml*/    
            printf("received %d bytes       %d       [ TERM ]\n", rc, index);
            printf("%d total bytes received for updating xml\n", totalFileSize);
            
            fprintf(outxml, "</CATALOG>");
            fflush(outxml);

            xml_check3 = 1; //Create new xml
            totalFileSize = 0;
            index = 0;
        }
        else {
            /* check if the first few characters look like an xml */
            int k = 0;
            int xml_check2 = 0;
            strncpy(xml_header, buf, (strlen("<ROEIMAGE>") + 1));

            printf("xml_check2 = %d\n", xml_check2);
            printf("xml_check3 = %d\n", xml_check3);

            int cmp = strncmp(xml_header, "<ROEIMAGE>", 10 * sizeof (char));
            printf("cmp = %d\n", cmp);
            if (cmp == 0) {
                xml_check2 = 1;
                printf(" packet is an xml \n");
            }
            
            if (xml_check2 == 1) {
                /* must be an xml */
                if (xml_check3 == 1) {
                    /* We need a new xml */
                    outxml = fopen("/data_output/imageindex.xml","w+");
                    if (outxml == NULL) {
                        printf("fopen error=%d %s\n", errno, strerror(errno));
                        //return errno;
                    }
                    /* Write XML declaration */
                    fprintf(outxml, "<?xml version=\"1.0\" encoding=\"ASCII\" standalone=\"yes\"?>\n");
                    fprintf(outxml, "<CATALOG>\n");
                    xml_check3 = 0;
                }
                
                /* append received update to disk */
                printf("received %d bytes       %d       [ XML ]\n", rc, index);
                count = fwrite(buf, sizeof (char), strlen(buf), outxml);
                fprintf(outxml, "\n");
            }
            else {
                /* save received data to image file */
                printf("received %d bytes       %d\n", rc, index);
                count = fwrite(buf, sizeof (char), rc, fp);
                if (count != rc) {
                    printf("fwrite error=%d %s\n", errno, strerror(errno));
                    break;
                }
                errcheck = fflush(fp);
                if (errcheck != 0) {
                    printf("fflush error=%d %s\n", errno, strerror(errno));
                    return errno;
                }

                totalFileSize += count;
                index++;
            }
        }
    }



    printf("Turn off RTS and DTR serial outputs\n");
    sigs = TIOCM_RTS + TIOCM_DTR;
    rc = ioctl(fd, TIOCMBIC, &sigs);
    if (rc < 0) {
        printf("negate DTR/RTS error=%d %s\n", errno, strerror(errno));
        return rc;
    }

    close(fd);
    fclose(fp);

    return 0;
}
